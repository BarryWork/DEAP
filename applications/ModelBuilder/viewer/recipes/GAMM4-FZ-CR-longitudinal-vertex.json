{"nodes":[{"name":"Display","id":"display-scatter","group":"Display","description":"something","inputs":[{"name":"input","type":"constant-text","id":"d2ff5368-b2ee-4325-81e7-936254f697cd"}],"outputs":[],"state":[],"screen-position":{"top":237,"left":1476},"gid":"532cbdf2-863e-4d63-9f82-da6c5c3b269c","enabledisable-id":"c84b6f22-e11f-49b5-94e5-f3fea0169977"},{"name":"NDA17","id":"data-nda17","group":"Data","description":"published release","inputs":[{"name":"in1","type":"constant-text","id":"058032eb-2a92-4698-b090-6b4b68524055"},{"name":"in2","type":"constant-text","id":"5467c3d0-18ad-42e6-b472-f549b56c62b7"},{"name":"in3","type":"constant-text","id":"d0b1e6c6-2e95-4e3a-badf-ce0051dbbf53"},{"name":"in4","type":"constant-text","id":"aba39fba-bfa3-457a-94a6-5bdce925fa14"},{"name":"in5","type":"constant-text","id":"2152e170-39c3-4621-bc9b-a1419c1e6f62"},{"name":"in6","type":"constant-text","id":"eaad9178-49a6-49e8-82ea-0bfabaecfae1"},{"name":"in7","type":"constant-text","id":"cf378cc2-5c7d-4096-9b3c-44e6eedf43b2"},{"name":"in8","type":"constant-text","id":"64de6011-ff94-4b30-8568-fec371dd6804"},{"name":"in9","type":"constant-text","id":"cda34d74-af74-41f3-9da3-b93c4f042af7"},{"name":"in10","type":"constant-text","id":"4bb52ced-5941-4611-9e73-809583bea80e"}],"outputs":[{"name":"out1","type":"constant-text","id":"1b27adc4-cdff-412c-872e-eef2f3b45f62"},{"name":"out2","type":"constant-text","id":"3ea903f2-93d1-4fa4-86a3-63e62e54bc59"},{"name":"out3","type":"constant-text","id":"6825b4df-6c7a-4d59-801c-f0bb2b52f327"},{"name":"out4","type":"constant-text","id":"45ea5645-07b0-4abe-bec0-d0aa9d481e2c"},{"name":"out5","type":"constant-text","id":"81450ccb-42b2-44b3-9dcb-16a791826b63"},{"name":"out6","type":"constant-text","id":"fe8ebb93-ed6a-4d42-98cb-82e072fad81a"},{"name":"out7","type":"constant-text","id":"d2dc7279-8eec-4f52-afca-c62d40486fd0"},{"name":"out8","type":"constant-text","id":"f6a6c305-7219-4be4-88d5-e8875da3ce11"},{"name":"out9","type":"constant-text","id":"bafe1270-7036-41b2-bf47-57f3f6404614"},{"name":"out10","type":"constant-text","id":"dfb15146-bb00-4655-858c-62ccec593001"}],"state":[{"name":"data-source","type":"text","gid":"3fe74f19-e9ad-40ae-bb4a-67602438499f","value":"NDA17"}],"screen-position":{"top":177,"left":653},"gid":"3fe74f19-e9ad-40ae-bb4a-67602438499f","enabledisable-id":"1f15a0d8-bf6d-4ff3-a7c8-6d0a24fd08fd"},{"name":"Display Text","id":"display-text","group":"Display","description":"something","inputs":[{"name":"input","type":"constant-text","id":"e376616d-2f95-408c-b225-860d270247e1"}],"outputs":[],"state":[],"screen-position":{"top":297,"left":1476},"gid":"2f69a29e-c34f-4901-85b7-28375fe65a75","enabledisable-id":"f0aec7e0-7d9d-4af5-8144-1d1b6162c86b"},{"name":"Measure Fixed","id":"measure-fixed","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"1ba4c758-4cd7-4bfe-8870-8588f311c769"}],"state":[{"name":"id","type":"text","gid":"edfaccc6-a8ea-485b-aa46-027a73f23a4a","value":"covfixed-SES"},{"name":"name","type":"text","gid":"edfaccc6-a8ea-485b-aa46-027a73f23a4a","value":"Race"},{"name":"default","type":"text","gid":"edfaccc6-a8ea-485b-aa46-027a73f23a4a","value":"race.4level"},{"name":"value","type":"text","gid":"edfaccc6-a8ea-485b-aa46-027a73f23a4a","value":"race.4level"}],"screen-position":{"top":357,"left":376},"gid":"edfaccc6-a8ea-485b-aa46-027a73f23a4a","enabledisable-id":"f4556710-c76c-4483-ab1e-947b2c312f4c"},{"name":"Measure All (multi)","id":"measure-all-multi","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"ced51cbb-abb4-45c3-a5e3-d4fa06cc6cc3"}],"state":[{"name":"id","type":"text","gid":"8898067d-5af4-4f2b-987e-ec18d342ec8d","value":"covuser"},{"name":"name","type":"text","gid":"8898067d-5af4-4f2b-987e-ec18d342ec8d","value":"Other Independent Variables"},{"name":"default","type":"text","gid":"8898067d-5af4-4f2b-987e-ec18d342ec8d","value":""},{"name":"value","type":"text","gid":"8898067d-5af4-4f2b-987e-ec18d342ec8d","value":""}],"screen-position":{"top":211,"left":377},"gid":"8898067d-5af4-4f2b-987e-ec18d342ec8d","enabledisable-id":"e659247e-a9ab-4f85-a66d-5e163b2050b2"},{"name":"Display","id":"display-scatter","group":"Display","description":"something","inputs":[{"name":"input","type":"constant-text","id":"e9dfd108-c1e1-4b85-b50b-eb3b27dc6394"}],"outputs":[],"state":[],"screen-position":{"top":372,"left":872},"gid":"dd017387-53dd-4118-8086-0e4c55b5b073","enabledisable-id":"95355ef9-9e54-44d6-ba96-b97b6debb6df"},{"name":"Measure Fixed","id":"measure-fixed","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"3226f90e-a1ea-4e78-8772-8fa60a49eac4"}],"state":[{"name":"id","type":"text","gid":"79b74b4c-558e-4c6b-986b-4af80d5bd642","value":"covfixed-GENDER"},{"name":"name","type":"text","gid":"79b74b4c-558e-4c6b-986b-4af80d5bd642","value":"SEX"},{"name":"default","type":"text","gid":"79b74b4c-558e-4c6b-986b-4af80d5bd642","value":"sex"},{"name":"value","type":"text","gid":"79b74b4c-558e-4c6b-986b-4af80d5bd642","value":"sex"}],"screen-position":{"top":535,"left":392},"gid":"79b74b4c-558e-4c6b-986b-4af80d5bd642","enabledisable-id":"0d50399f-f5b8-4423-ab20-1681f1d20885"},{"name":"Measure Fixed","id":"measure-fixed","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"f046675d-5841-44cb-ab5e-60912f5c179a"}],"state":[{"name":"id","type":"text","gid":"8ae5b439-3b4e-4b25-b51b-20aca0df78fa","value":"covfixed-EDU"},{"name":"name","type":"text","gid":"8ae5b439-3b4e-4b25-b51b-20aca0df78fa","value":"EDU"},{"name":"default","type":"text","gid":"8ae5b439-3b4e-4b25-b51b-20aca0df78fa","value":"high.educ.bl"},{"name":"value","type":"text","gid":"8ae5b439-3b4e-4b25-b51b-20aca0df78fa","value":"high.educ.bl"}],"screen-position":{"top":597,"left":393},"gid":"8ae5b439-3b4e-4b25-b51b-20aca0df78fa","enabledisable-id":"ad85424b-d4cd-4ff5-92c2-d8e568860202"},{"name":"Measure Fixed","id":"measure-fixed","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"a090b405-f3af-4655-8706-24634c69200b"}],"state":[{"name":"id","type":"text","gid":"e1c54d37-f458-4be5-bfc7-58053bb08bdd","value":"covfixed-INC"},{"name":"name","type":"text","gid":"e1c54d37-f458-4be5-bfc7-58053bb08bdd","value":"Income"},{"name":"default","type":"text","gid":"e1c54d37-f458-4be5-bfc7-58053bb08bdd","value":"household.income.bl"},{"name":"value","type":"text","gid":"e1c54d37-f458-4be5-bfc7-58053bb08bdd","value":"household.income.bl"}],"screen-position":{"top":650,"left":392},"gid":"e1c54d37-f458-4be5-bfc7-58053bb08bdd","enabledisable-id":"28fb9525-fef0-453f-b747-67b4e973f5a9"},{"name":"Measure Fixed","id":"measure-fixed","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"3c06fa2a-5479-49f3-b1c9-fe1098420a57"}],"state":[{"name":"id","type":"text","gid":"1166850f-7097-4c58-a0f5-0a5ce64dabb8","value":"covfixed-MARITAL"},{"name":"name","type":"text","gid":"1166850f-7097-4c58-a0f5-0a5ce64dabb8","value":"Marital"},{"name":"default","type":"text","gid":"1166850f-7097-4c58-a0f5-0a5ce64dabb8","value":"married.bl"},{"name":"value","type":"text","gid":"1166850f-7097-4c58-a0f5-0a5ce64dabb8","value":"married.bl"}],"screen-position":{"top":703,"left":395},"gid":"1166850f-7097-4c58-a0f5-0a5ce64dabb8","enabledisable-id":"3ea8d4ce-d990-4dcc-b6f7-9e46756b0454"},{"name":"Measure Fixed","id":"measure-fixed","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"dfbdf064-5cf5-4087-b73f-e093fb340c12"}],"state":[{"name":"id","type":"text","gid":"5c77be8f-2ba0-4379-bf27-394f16177c24","value":"covfixed-AGE"},{"name":"name","type":"text","gid":"5c77be8f-2ba0-4379-bf27-394f16177c24","value":"AGE"},{"name":"default","type":"text","gid":"5c77be8f-2ba0-4379-bf27-394f16177c24","value":"age"},{"name":"value","type":"text","gid":"5c77be8f-2ba0-4379-bf27-394f16177c24","value":"age"}],"screen-position":{"top":766,"left":394},"gid":"5c77be8f-2ba0-4379-bf27-394f16177c24","enabledisable-id":"fd508c72-1033-446f-bdea-744d14512684"},{"name":"Display Line","id":"display-line","group":"Display","description":"something","inputs":[{"name":"input","type":"constant-text","id":"cc9e7950-f3b2-4a30-8446-456a05a22ffa"}],"outputs":[],"state":[],"screen-position":{"top":352,"left":1475},"gid":"ab7ce704-2559-4299-b838-88eb8803d854","enabledisable-id":"794adf52-0e25-49e7-a38e-67efed0f086a"},{"name":"Display Tunnel","id":"display-tunnel","group":"Display","description":"something","inputs":[{"name":"input","type":"constant-text","id":"62b02bc1-048f-43b2-8586-8fb643b1ee6b"}],"outputs":[],"state":[],"screen-position":{"top":414,"left":1475},"gid":"e9ec9481-f9f9-464c-a567-e4931dae43f4","enabledisable-id":"91ac25c0-9a3e-491f-8aff-d35c54a7db3f"},{"name":"Measure All (multi)","id":"measure-all-multi","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"a7cc9f44-4879-4118-b0ab-51f8e6169502"}],"state":[{"name":"id","type":"text","gid":"74e03bc4-592a-4f6d-b10b-ae134f4a3c2d","value":"smo.var"},{"name":"name","type":"text","gid":"74e03bc4-592a-4f6d-b10b-ae134f4a3c2d","value":"Smooth variables"},{"name":"default","type":"text","gid":"74e03bc4-592a-4f6d-b10b-ae134f4a3c2d"},{"name":"value","type":"text","gid":"74e03bc4-592a-4f6d-b10b-ae134f4a3c2d"}],"screen-position":{"top":441,"left":960},"gid":"74e03bc4-592a-4f6d-b10b-ae134f4a3c2d","enabledisable-id":"c762d60e-59a7-4688-96c3-49b43fd77acf"},{"name":"Measure All (multi)","id":"measure-all-multi","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"49e486ad-699c-412f-963c-d1ec0709cff9"}],"state":[{"name":"id","type":"text","gid":"d73b51e5-7f4b-47d1-93e9-4695339dcdb7","value":"log.var"},{"name":"name","type":"text","gid":"d73b51e5-7f4b-47d1-93e9-4695339dcdb7","value":"Log tranfomation"},{"name":"default","type":"text","gid":"d73b51e5-7f4b-47d1-93e9-4695339dcdb7"},{"name":"value","type":"text","gid":"d73b51e5-7f4b-47d1-93e9-4695339dcdb7"}],"screen-position":{"top":497,"left":961},"gid":"d73b51e5-7f4b-47d1-93e9-4695339dcdb7","enabledisable-id":"0a56230c-43b4-446c-b459-8f67e221eb00"},{"name":"Measure All (multi)","id":"measure-all-multi","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"28b12798-18bf-4a96-a27d-36c70120d0f6"}],"state":[{"name":"id","type":"text","gid":"a39dce10-ff4d-4315-bc1a-8cdd6e3d80f4","value":"int.var"},{"name":"name","type":"text","gid":"a39dce10-ff4d-4315-bc1a-8cdd6e3d80f4","value":"Interaction terms"},{"name":"default","type":"text","gid":"a39dce10-ff4d-4315-bc1a-8cdd6e3d80f4"},{"name":"value","type":"text","gid":"a39dce10-ff4d-4315-bc1a-8cdd6e3d80f4"}],"screen-position":{"top":559,"left":960},"gid":"a39dce10-ff4d-4315-bc1a-8cdd6e3d80f4","enabledisable-id":"a625024d-84c6-4ab5-afc2-8b97d6978517"},{"name":"Measure All (multi)","id":"measure-all-multi","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"08ddaa6d-2c77-4ade-ad36-d04596416214"}],"state":[{"name":"id","type":"text","gid":"3379f0c3-9925-4ce2-ba0e-9067d3cfc77e","value":"sq.var"},{"name":"name","type":"text","gid":"3379f0c3-9925-4ce2-ba0e-9067d3cfc77e","value":"Square terms"},{"name":"default","type":"text","gid":"3379f0c3-9925-4ce2-ba0e-9067d3cfc77e"},{"name":"value","type":"text","gid":"3379f0c3-9925-4ce2-ba0e-9067d3cfc77e"}],"screen-position":{"top":632,"left":956},"gid":"3379f0c3-9925-4ce2-ba0e-9067d3cfc77e","enabledisable-id":"43631271-058d-4caa-a505-6e8a9c2c63ea"},{"name":"Measure All (single)","id":"measure-single","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"b0b845c1-9494-462b-882a-b97383400416"}],"state":[{"name":"id","type":"text","gid":"dc6871d1-0fb3-4c86-a3ed-853909bfa05b","value":"depvar"},{"name":"name","type":"text","gid":"dc6871d1-0fb3-4c86-a3ed-853909bfa05b","value":"Dependent Variable (Y-axis)"},{"name":"default","type":"text","gid":"dc6871d1-0fb3-4c86-a3ed-853909bfa05b","value":"nihtbx_fluidcomp_uncorrected"},{"name":"value","type":"text","gid":"dc6871d1-0fb3-4c86-a3ed-853909bfa05b","value":"nihtbx_fluidcomp_uncorrected"}],"screen-position":{"top":97,"left":392},"gid":"dc6871d1-0fb3-4c86-a3ed-853909bfa05b","enabledisable-id":"b0d76d91-5280-41a7-a218-c7140e4fea9b"},{"name":"Measure All (single)","id":"measure-single","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"10c3487e-51ff-4862-b3d0-226fd4107478"}],"state":[{"name":"id","type":"text","gid":"00dd2e0c-4832-4a4f-bc25-9a49b5da81ce","value":"indepvar"},{"name":"name","type":"text","gid":"00dd2e0c-4832-4a4f-bc25-9a49b5da81ce","value":"Independent Variable (X-axis, for plotting)"},{"name":"default","type":"text","gid":"00dd2e0c-4832-4a4f-bc25-9a49b5da81ce","value":"nihtbx_picvocab_uncorrected"},{"name":"value","type":"text","gid":"00dd2e0c-4832-4a4f-bc25-9a49b5da81ce","value":"nihtbx_picvocab_uncorrected"}],"screen-position":{"top":164,"left":393},"gid":"00dd2e0c-4832-4a4f-bc25-9a49b5da81ce","enabledisable-id":"33572aea-ceaa-4d9c-9fd0-44d368bc3091"},{"name":"Measure All (single)","id":"measure-single","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"fffb4252-410a-4b9e-82e7-323d0c8ca46d"}],"state":[{"name":"id","type":"text","gid":"87e5931b-5dee-4af5-acda-cb6d2159f62d","value":"grvar"},{"name":"name","type":"text","gid":"87e5931b-5dee-4af5-acda-cb6d2159f62d","value":"Grouping Variable (for interaction and plotting)"},{"name":"default","type":"text","gid":"87e5931b-5dee-4af5-acda-cb6d2159f62d"},{"name":"value","type":"text","gid":"87e5931b-5dee-4af5-acda-cb6d2159f62d"}],"screen-position":{"top":698,"left":958},"gid":"87e5931b-5dee-4af5-acda-cb6d2159f62d","enabledisable-id":"b86a9aca-9f4b-4420-9de3-23f778af9a9d"},{"name":"Measure All (multi)","id":"measure-all-multi","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"049c008e-3e9f-43fb-bb41-0eefbf4937b8"}],"state":[{"name":"id","type":"text","gid":"087d2037-761a-47be-a65b-cbf13789f4ab","value":"ws.var"},{"name":"name","type":"text","gid":"087d2037-761a-47be-a65b-cbf13789f4ab","value":"winsorizing and sensing"},{"name":"default","type":"text","gid":"087d2037-761a-47be-a65b-cbf13789f4ab"},{"name":"value","type":"text","gid":"087d2037-761a-47be-a65b-cbf13789f4ab"}],"screen-position":{"top":762,"left":960},"gid":"087d2037-761a-47be-a65b-cbf13789f4ab","enabledisable-id":"3a4f46c9-ed86-4d1d-89b6-0ba83820f561"},{"name":"Measure Fixed","id":"measure-fixed","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"aa991afb-edc4-4854-8c3c-b2ecf6c5b3da"}],"state":[{"name":"id","type":"text","gid":"64a89c3c-5bd3-4c3b-9304-38e4a56d2058","value":"random-Family"},{"name":"name","type":"text","gid":"64a89c3c-5bd3-4c3b-9304-38e4a56d2058","value":"FAMILY"},{"name":"default","type":"text","gid":"64a89c3c-5bd3-4c3b-9304-38e4a56d2058","value":"rel_family_id"},{"name":"value","type":"text","gid":"64a89c3c-5bd3-4c3b-9304-38e4a56d2058","value":"rel_family_id"}],"screen-position":{"top":849,"left":384},"gid":"64a89c3c-5bd3-4c3b-9304-38e4a56d2058","enabledisable-id":"1f806560-e1ef-4adf-a85c-78359cfc27be"},{"name":"Measure Fixed","id":"measure-fixed","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"80b11404-28a4-43c9-a6b7-cc68362af908"}],"state":[{"name":"id","type":"text","gid":"b4150f93-caf2-4715-a08a-27567eb4b8a2","value":"random-SITE"},{"name":"name","type":"text","gid":"b4150f93-caf2-4715-a08a-27567eb4b8a2","value":"SITE"},{"name":"default","type":"text","gid":"b4150f93-caf2-4715-a08a-27567eb4b8a2","value":"abcd_site"},{"name":"value","type":"text","gid":"b4150f93-caf2-4715-a08a-27567eb4b8a2","value":"abcd_site"}],"screen-position":{"top":901,"left":399},"gid":"b4150f93-caf2-4715-a08a-27567eb4b8a2","enabledisable-id":"2e887aab-6a4e-4989-8064-f62513e5aca6"},{"name":"Measure All (single)","id":"measure-single","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"05bad52b-5789-4e5c-9e9e-c7c469f3a93e"}],"state":[{"name":"id","type":"text","gid":"f3be4f2c-ca41-49d1-b770-59bed54ec85d","value":"fl.var"},{"name":"name","type":"text","gid":"f3be4f2c-ca41-49d1-b770-59bed54ec85d","value":"Select subset of sessions"},{"name":"default","type":"text","gid":"f3be4f2c-ca41-49d1-b770-59bed54ec85d"},{"name":"value","type":"text","gid":"f3be4f2c-ca41-49d1-b770-59bed54ec85d"}],"screen-position":{"top":892,"left":962},"gid":"f3be4f2c-ca41-49d1-b770-59bed54ec85d","enabledisable-id":"d3db4961-5752-4f65-81bf-7f9e0004b755"},{"name":"Measure Fixed","id":"measure-fixed","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"60b3ed6f-23ca-4bd0-be3d-e1879fd6fe16"}],"state":[{"name":"id","type":"text","gid":"3b23ac4b-79ce-4a8b-955c-888478bf98aa","value":"random-SUBJECT"},{"name":"name","type":"text","gid":"3b23ac4b-79ce-4a8b-955c-888478bf98aa","value":"SUBJECT"},{"name":"default","type":"text","gid":"3b23ac4b-79ce-4a8b-955c-888478bf98aa","value":"src_subject_id"},{"name":"value","type":"text","gid":"3b23ac4b-79ce-4a8b-955c-888478bf98aa","value":""}],"screen-position":{"top":974,"left":383},"gid":"3b23ac4b-79ce-4a8b-955c-888478bf98aa","enabledisable-id":"38c2577c-efee-4412-bbdd-6bb0f063f061"},{"name":"Measure Fixed","id":"measure-fixed","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"5533ca80-de45-4d4b-9da9-e8f85ff30a57"}],"state":[{"name":"id","type":"text","gid":"7fbe0047-c0f3-4bda-89ca-7cbb00cca9d6","value":"random-DEVICE"},{"name":"name","type":"text","gid":"7fbe0047-c0f3-4bda-89ca-7cbb00cca9d6","value":"DEVICE"},{"name":"default","type":"text","gid":"7fbe0047-c0f3-4bda-89ca-7cbb00cca9d6","value":"mri_info_device.serial.number"},{"name":"value","type":"text","gid":"7fbe0047-c0f3-4bda-89ca-7cbb00cca9d6","value":""}],"screen-position":{"top":1096,"left":386},"gid":"7fbe0047-c0f3-4bda-89ca-7cbb00cca9d6","enabledisable-id":"4f41ac09-56de-4dff-a459-672c301d3bde"},{"name":"Measure Fixed","id":"measure-fixed","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"c28a88a5-17f7-4302-8899-e7f506a471a1"}],"state":[{"name":"id","type":"text","gid":"43fe58be-66a2-418b-b413-b9f11451c96e","value":"covfixed-HIS"},{"name":"name","type":"text","gid":"43fe58be-66a2-418b-b413-b9f11451c96e","value":"Hispanic"},{"name":"default","type":"text","gid":"43fe58be-66a2-418b-b413-b9f11451c96e","value":"hisp"},{"name":"value","type":"text","gid":"43fe58be-66a2-418b-b413-b9f11451c96e","value":"hisp"}],"screen-position":{"top":409,"left":385},"gid":"43fe58be-66a2-418b-b413-b9f11451c96e","enabledisable-id":"bc9917c5-f1bf-4977-b7a9-e45c8ed9cc54"},{"name":"GAMM4","id":"model-gamm4","group":"Model","description":"A GAMM4 model","inputs":[{"name":"dep. var.","type":"constant-text","id":"ae106892-c760-4b24-a0f4-f03b62aa7753"},{"name":"ind. var.","type":"constant-text","id":"0c02bfa9-50d8-434c-806d-e31db3b329a0"},{"name":"user cov.","type":"constant-text","id":"90f25d94-bb14-4c95-9ee0-623355c2eeb5"},{"name":"cov. fixed","type":"constant-text","id":"59afa45a-6816-4ae0-be64-1e5afd27e98f"},{"name":"smo. var","type":"constant-text","id":"176a97bd-4a9b-4a84-bf62-cffa66c78d0f"},{"name":"log. var","type":"constant-text","id":"6851aad2-cda1-4047-b45a-48b604500cb0"},{"name":"int. var","type":"constant-text","id":"d88cb788-2081-422d-ad93-52f520ad52af"},{"name":"sq. var","type":"constant-text","id":"5baa8968-e52e-41a8-ab8a-2014d3c1626b"},{"name":"gr. var","type":"constant-text","id":"5bb4718f-4031-4cd7-a20f-d01f833d122b"},{"name":"ws. var","type":"constant-text","id":"35b173e3-0070-43c3-bbf5-d86afd8c194a"},{"name":"fl. var","type":"constant-text","id":"26486264-8eb2-4942-85d5-9d1de60d1c41"},{"name":"rand. var","type":"constant-text","id":"3b4cc89d-9514-489a-a844-4a66c02675dc"},{"name":"weight. var","type":"constant-text","id":"caab4d31-ae0f-4638-9c19-79863c170fcf"}],"outputs":[{"name":"scatter","type":"scatter","id":"55db9226-77e7-4d5e-a940-603786490cc9"},{"name":"statistics","type":"constant-text","id":"a0f7e069-92c5-4466-97b6-8246c6e98500"},{"name":"lineplot","type":"scatter","id":"209b8148-ea1c-4ec9-8b68-da88a43d9d8c"},{"name":"tunnel","type":"scatter","id":"e2c610a7-093b-4f75-9bc6-2c587125ea34"}],"state":[{"name":"model","type":"textarea","gid":"73d0ca37-205c-4c90-a4de-8d63074a31d4","value":"\n#####################\n##  local loading  ##\n#####################\nLOCAL = FALSE\nlocal.load = function(dir){\n  local.json.file = paste0(dir , \"\/data\/data.json\")\n  d = rjson::fromJSON(file = local.json.file)\n  \n  d.mat = matrix(NA, ncol = length(d), nrow = length(d[[1]]))\n  for(ii in 1:length(d)){\n    d.mat[,ii] = d[[ii]]\n  }\n  data = as.data.frame(d.mat)\n  names(data) = names(d)\n  return(data)\n}\nif(LOCAL){\n  #set directory to saved model folder\n  dir = \"\/path\/to\/GAMM4\"\n  data = local.load(dir)\n}\n##########################\n##  user customization  ##\n##########################\nTEST = FALSE\n# Change the coding from factor levels to numbers\n#levels(data$physical_activity1_y) = c(\"\", 0:7);\n#data$physical_activity1_y = as.numeric(as.character(data$physical_activity1_y))\n\n# Change the reference category of a factor level variable\n# data$sex <- factor(data$sex, levels=c(\"M\",\"F\"))\n\nprint(toJSON(inputs))\n\nif (!('gamm4'     %in% installed.packages()[,\"Package\"])) install.packages('gamm4')\nif (!('rjson'     %in% installed.packages()[,\"Package\"])) install.packages('rjson')\nif (!('stargazer' %in% installed.packages()[,\"Package\"])) install.packages('stargazer')\nif (!('knitr'     %in% installed.packages()[,\"Package\"])) install.packages('knitr')\nif (!('MuMIn'     %in% installed.packages()[,\"Package\"])) install.packages('MuMIn')\nif (!('R.matlab'  %in% installed.packages()[,\"Package\"])) install.packages('R.matlab')\nif (!('tableone'  %in% installed.packages()[,\"Package\"])) install.packages('tableone')\nif(!\"gamm4\" %in% .packages())     library(gamm4)\nif(!\"rjson\" %in% .packages())     library(rjson)\nif(!\"stargazer\" %in% .packages()) library(stargazer)\nif(!\"knitr\" %in% .packages())     library(knitr)\nif(!\"MuMIn\" %in% .packages())     library(MuMIn)\nif(!\"R.matlab\" %in% .packages())  library(R.matlab)\nif(!\"tableone\" %in% .packages())  library(tableone)\n\nextract.variables = function(a){\n  rt = c()\n  for (l in 1:length(a) ){ \n    if(length(a[[l]]) > 0){\n      for(e in 1:length(a[[l]])){\n        if(unlist(a[[l]][[e]]) != \"\")\n          rt = c(rt, unlist(a[[l]][[e]]))\n      } \n    }\n  }\n  rt_inster = c()\n  for( item in 1:length(rt)){\n    if(!is.character(rt[item])){\n      next\n    }\n    if(length(unlist(strsplit(rt[item],\"[*]\"))) > 1){\n      rt_inster = c(rt_inster, unlist(strsplit(rt[item],\"[*]\")))\n    }\n    else if(length(unlist(strsplit(rt[item],\"[+]\"))) > 1){\n      rt_inster = c(rt_inster, unlist(strsplit(rt[item],\"[+]\")))\n    }\n    \n    else if(length(unlist(strsplit(rt[item],\"^2\", fixed=TRUE))) > 1){\n      rt_inster = c(rt_inster, unlist(strsplit(rt[item],\"^2\", fixed=TRUE)))\n    }\n    else if( length(regmatches(rt[item], gregexpr(\"(?<=\\\\().*?(?=\\\\))\", rt[item], perl=T))[[1]] ) > 0 ){\n      \n      rt_inster = c(rt_inster, regmatches(rt[item], gregexpr(\"(?<=\\\\().*?(?=\\\\))\", rt[item], perl=T))[[1]])\n    }else{\n      rt_inster = c(rt_inster, rt[item])\n    }\n  }\n  rt = rt_inster\n  return(rt);\n}\n\nis.user.score = function(name){\n  rt = FALSE\n  name = paste0(\"\/var\/www\/html\/data\/ABCD\/Scores\/data\/\", strsplit(username,\"_\")[[1]][1],\"\/\",name,\".rds\")\n  if(file.exists(name))\n    rt = TRUE\n  return(rt)\n}\n\nis.user.score.admin = function(name){\n  rt = FALSE\n  name = paste0(\"\/var\/www\/html\/data\/ABCD\/Scores\/data\/admin\/\",name,\".rds\")\n  if(file.exists(name))\n    rt = TRUE\n  return(rt)\n}\n\nif(length(unlist(inputs[['dep.var.']])) == 0 ){\n  stop(\"Dependent variable is empty.\")\n}\n\n\n\nvarList.initial = extract.variables(inputs)\n#if smooth by variables, need to split first\nif(sum(grepl(\"by =\",varList.initial))>=1){\n  s.by.split = varList.initial[grepl(\"by =\",varList.initial)]\n  split.vars = unlist(strsplit(s.by.split, \", by = \"))\n  varList.initial = c(varList.initial,split.vars)\n  varList.initial = varList.initial[!duplicated(varList.initial)]\n}\n\n######################\n##  ROI analysis?   ##\n######################\n#if _desikan_roi_all variable is in inputs, run ROI analyses\nroi_type = \"desikan_roi_all\"\nroi_indicators = grepl(roi_type, varList.initial)\nis.roi.analysis=F\nif(any(roi_indicators)){\n  is.roi.analysis=T\n  roi = varList.initial[roi_indicators]\n  roi_base = strsplit(roi, \"roi_all\")[[1]]\n  all_rois_base = names(data)[grepl(roi_base, names(data))]\n  #remove _mean variables\n  all_rois_base = all_rois_base[!grepl(\"mean\",all_rois_base)]\n  \n  #create image data frame to merge later, assume baseline only\n  dat.image = data[data$eventname==\"baseline_year_1_arm_1\",c(\"src_subject_id\",all_rois_base)]\n  # varList.initial = c(varList.initial, all_rois_base)\n}\n\n\n\nvars.in.data = varList.initial[varList.initial %in% names(data)]\nvars.keep = c(\"src_subject_id\",\"eventname\",\"rel_family_id\",\"abcd_site\",vars.in.data)\nvars.keep = vars.keep[!duplicated(vars.keep)]\ndata = data[,vars.keep]\n\nfor( name in extract.variables(inputs)){\n  if ( name %in% names(data)){\n    next;\n  }else if ( is.user.score(name)){\n    user_data =  readRDS( paste0(\"\/var\/www\/html\/data\/ABCD\/Scores\/data\/\",strsplit(username,\"_\")[[1]][1],\"\/\",name,\".rds\"))\n    data = merge(data, user_data);\n  }else if ( is.user.score.admin(name)){\n    user_data =  readRDS( paste0(\"\/var\/www\/html\/data\/ABCD\/Scores\/data\/admin\/\",name,\".rds\"))\n    data = merge(data, user_data);\n  }\n  #else {\n  #    stop(paste( name,\"does not exist.\"))\n  #}\n  \n  \n}\n##################\n##  functions   ##\n##################\n\nMode <- function(x) {\n  ux <- unique(x)\n  ux[which.max(tabulate(match(x, ux)))]\n}\n\nsep.vars = function(x){\n  x = gsub(\" \", \"\", x, fixed = TRUE)\n  x = unlist(strsplit(x,\"+\",fixed=T))\n  return(x)\n}\n\ncensor =  function(x, fraction=.005){\n  if(length(fraction) != 1 || fraction < 0 || fraction > 1){\n    stop(\"bad value for 'fraction'\")\n  }\n  lim <- quantile(x, probs=c(fraction\/2, 1-fraction\/2), na.rm = T)\n  x[ x < lim[1] ] <- NA\n  x[ x > lim[2] ] <- NA\n  x\n}\n\n#########################\n##  data  extraction   ##\n#########################\n\ntrigger.warning = F\n\n#exit script silently if @inputs is empyt\nempty = T;\nfor (key in names(inputs)){\n  #print(inputs[[key]]);\n  #print(length(inputs[[key]]))\n  if(length(inputs[[key]]) != 0 && inputs[[key]] != \"\"){\n    empty = F;\n  }\n}\n\nif(empty){\n  options(warn=-1)\n  opt <- options(show.error.messages=FALSE) \n  on.exit(options(opt)) \n  stop() \n}\n\n#By using Rserve gamm4 is already loaded\n\n### censor\/windsorize first\nwsVar = unlist(inputs[['ws.var']])\nwsVar = sep.vars(wsVar)\nif(length(wsVar)>0){\n  for(ii in 1:length(wsVar)){\n    if(class(data[,wsVar[ii]]) == \"numeric\"){\n      data[,wsVar[ii]] = censor(data[,wsVar[ii]])\n    }\n  }\n}\n\ndependendVar   = unlist(inputs[['dep.var.']]);\ndependendVar.name = NULL\n\nif(length(dependendVar) == 0 ){\n  stop(\"Dependent variable is empty.\")\n}\n\n\n##if y is log-transformed...\nif(substring(dependendVar,1,4) == \"log(\"){\n  dependendVar.name = substring(dependendVar,5,nchar(dependendVar)-1)\n  if(sum(data[[dependendVar.name]] <= 0, na.rm=T) > 0){\n    data[[dependendVar.name]][data[[dependendVar.name]] <= 0] = NA\n    trigger.warning = T\n    warning.logging.0 = paste0(\"1 or more log transformed variable contains values <=0. All <=0 values replaced with NA.\")\n  }\n  data$Y.log = log(data[[dependendVar.name]])\n  new.name = paste0(\"log.\",dependendVar.name)\n  names(data)[names(data) == \"Y.log\"] = new.name\n  dependendVar = new.name\n}\n\n#***change***------may need to change this for vertex, \n#     since dependent variable may be something we loop through\n\n\n##is the dependent variable actually voxel-wise?\nvox_fl = list.files(path = \"\/var\/www\/html\/data\/ABCD\/Rds\/\", pattern = paste0(\"*\",dependendVar,\"*\"));\nis.voxel.analysis = F\nif( length(vox_fl) > 0){\n  is.voxel.analysis = T\n}\n\nif( dependendVar %in% names(data)){\n  if(is.factor(data[[dependendVar]])){\n    if(nlevels(data[[dependendVar]]) > 2){\n      stop(\"Categorical variables with more than 2 levels are not supported as dependent variables. \\nConsider converting your categorical variable into a continuous variable.\")\n    }\n  }\n} else if(is.voxel.analysis == F & is.roi.analysis == F){\n  stop(paste(\"Dependent variable <\", dependendVar ,\">does not exist in the database\"));\n}\n\n\n\nindependendVar = unlist(inputs[['ind.var.']]);\nusercovVar     = paste(unlist(inputs[['usercov.']]),  sep='+')\n\nsmoothVar.all = unlist(inputs[['smo.var']])\nsmoothVar.all = sep.vars(smoothVar.all)\n\nlogVar = unlist(inputs[['log.var']])\nlogVar = sep.vars(logVar)\n#check if 0's in logged vars. if so, add 0.0001\nstrip.log = substring(logVar,5,nchar(logVar)-1)\nif(length(strip.log)>0){\n  if(sum(data[,strip.log]<=0 , na.rm=T) > 0){\n    trigger.warning = T\n    warning.logging.0 = paste0(\"1 or more log transformed variable contains values <=0. All <=0 values replaced with NA.\")\n    for(ii in 1:length(strip.log)){\n      log.var_i = strip.log[ii]\n      if(sum(data[,log.var_i]<=0 , na.rm=T) > 0){\n        #data[[log.var_i]][data[[log.var_i]] == 0] = 0.0001\n        data[[log.var_i]][data[[log.var_i]] <= 0] = NA\n        \n      }\n    }\n  }\n}\n\ninteractionVar = unlist(inputs[['int.var']])\n\nsqVar = unlist(inputs[['sq.var']])\nsqVar = sep.vars(sqVar)\nsqVar = substring(sqVar,1,nchar(sqVar)-2)\n\nsqVar_SQUARED = NULL\nif(length(sqVar)>0){\n  for(ii in 1:length(sqVar)){\n    sqVar_SQUARED[ii] = paste0(sqVar[ii],\"_SQUARED\")\n    data[,sqVar_SQUARED[ii]] = data[,sqVar[ii]]^2\n  }\n}\n\ngroupVar = unlist(inputs[['gr.var']])\nif(length(groupVar) > 0){\n  if(is.character(groupVar) & nchar(groupVar) ==0){\n    groupVar = NULL \n  } \n}\n\nsubsetVar   = unlist(inputs[['fl.var']]);\nif(length(subsetVar) > 0){\n  if(is.character(subsetVar) & nchar(subsetVar) ==0){\n    subsetVar = NULL \n  } \n}\n#Interacting grouping variable with independent variable\nif(length(groupVar)>0){\n  #may need to change it instead of searching for the string, it strips string first and looks for exact match\n  is.smooth = grepl(independendVar, smoothVar.all)\n  is.log =    independendVar %in% substring(logVar,5,nchar(logVar)-1)\n  is.square = independendVar %in% sqVar\n  ## If independent var is smooth\n  if( sum(is.smooth) > 0 ){\n    #replace s(independendVar) with s(independendVar, by = groupVar)\n    smoothVar.all[is.smooth] = paste0(\"s(\", independendVar,\",by=\",groupVar, \")\")\n  } else if(is.square){\n    #else if squared, add var*groupvar and var_SQUARED*groupvar\n    interactionVar = c(interactionVar, paste0(independendVar,\"*\",groupVar), paste0(independendVar,\"_SQUARED*\",groupVar) )\n  } else if(is.log){    \n    # else if log, interact with log(var)\n    log.independent = logVar[independendVar == substring(logVar,5,nchar(logVar)-1)]\n    interactionVar = c(interactionVar, paste0(log.independent,\"*\",groupVar) )\n  } else {\n    # else make normal interaction\n    interactionVar = c(interactionVar, paste0(independendVar,\"*\",groupVar) )\n  }\n}  #may need to do another if with ^2 independent variables\nsmoothVarInt.ind = grepl(\",by=\", smoothVar.all)\nsmoothVarInt = smoothVar.all[smoothVarInt.ind]\nsmoothVar =    smoothVar.all[!smoothVarInt.ind]\n\nif(0 %in% nchar(sqVar)) sqVar = character()\n\nprint(sqVar)\nprint(paste(\"length sqVar\",length(sqVar)))\n#nestVar = c(\"Site\", \"FamilyID\")\n#usercovVar =  usercovVar[!(usercovVar %in% nestVar)]\n\n#TODO: seperate Site and Familiy to another catagory of random effect\n\n#if(include.random.site){\n#  inputs[['cov.fixed']][[which(unlist(inputs[['cov.fixed']]) == \"abcd_site\")]] = NULL\n#}\n#inputs[['cov.fixed']][[which(unlist(inputs[['cov.fixed']]) == \"rel_family_id\")]] = NULL\n\ncovfixedVar    = paste(unlist(inputs[['cov.fixed']]), sep='+')\n\nsmoothVarInt.stripped.term1 = \"\"\nsmoothVarInt.stripped.term2 = \"\"\n\n\nif(length(smoothVarInt)>0){\n  smoothVarInt.stripped.term1 = unlist(lapply( strsplit(smoothVarInt,\",\"), function(x)x[[1]]))\n  smoothVarInt.stripped.term1 = substring(smoothVarInt.stripped.term1,3,nchar(smoothVarInt.stripped.term1))\n  smoothVarInt.stripped.term2 = unlist(lapply( strsplit(smoothVarInt,\"by=\"), function(x)x[[2]]))\n  smoothVarInt.stripped.term2 = substring(smoothVarInt.stripped.term2,1,nchar(smoothVarInt.stripped.term2)-1)\n}\n\n### if usercovVar's have been transformed, then they are stored in usercovVar as well as the \n### transformed vars (smoothVar, logVar, etc.), in which they will need to be removed from\n### usercovVar before putting into formula\nprint(paste(\"before remove\",usercovVar))\nprint(c( substring(smoothVar,3,nchar(smoothVar)-1),\n         smoothVarInt.stripped.term1,\n         smoothVarInt.stripped.term2,\n         substring(logVar,5,nchar(logVar)-1),\n         sqVar ))\ncov.ind.remove = usercovVar %in% c( substring(smoothVar,3,nchar(smoothVar)-1),\n                                    smoothVarInt.stripped.term1,\n                                    smoothVarInt.stripped.term2,\n                                    substring(logVar,5,nchar(logVar)-1),\n                                    sqVar )\nif(sum(cov.ind.remove)>0 ){\n  usercovVar = usercovVar[!cov.ind.remove]\n}\nprint(paste(\"after remove\",usercovVar))\n\n#remove covfixedVar when it is a smooth, smooth interaction (first variable), or log -- should usually only be age of covfixedVar\n#ok to keep it in as interaction, squared, or smooth interaction term\ncovfixedVar.ind.remove = covfixedVar %in% c( substring(smoothVar,3,nchar(smoothVar)-1),\n                                             smoothVarInt.stripped.term1,\n                                             substring(logVar,5,nchar(logVar)-1))\nif(sum(covfixedVar.ind.remove)>0 ){\n  covfixedVar = covfixedVar[!covfixedVar.ind.remove]\n}\n\n\n##**added\nif( is.null(data[[independendVar]])){\n  print(\"247\\n\")\n  independendVar.Vox = independendVar;\n  form_arr = c(usercovVar, covfixedVar, smoothVar.all, logVar, interactionVar, sqVar, sqVar_SQUARED);\n} else {\n  print(\"253\\n\")\n  form_arr = c(independendVar, usercovVar, covfixedVar, smoothVar.all, logVar, interactionVar, sqVar, sqVar_SQUARED);\n}\n\n# form_arr = c(independendVar, usercovVar,covfixedVar, smoothVar.all, logVar, interactionVar, sqVar, sqVar_SQUARED);\n#form_arr = c(independendVar, usercovVar,covfixedVar, smoothVar, logVar, interactionVar, sqVar, sqVar_SQUARED);\n#form_arr = c(independendVar, usercovVar,covfixedVar, smoothVar, logVar, interactionVar, sqVar, sqVar_SQUARED, groupVar);\n\n### similarly for the independent variable...\n#if independent variable is a smooth variable, log variable, or squared variable remove independendendVar from form_arr\nif(independendVar %in% c(  substring(smoothVar,3,nchar(smoothVar)-1),\n                           smoothVarInt.stripped.term1,\n                           substring(logVar,5,nchar(logVar)-1),\n                           sqVar ) ){\n  form_arr = c(usercovVar,covfixedVar, smoothVar.all, logVar, interactionVar, sqVar, sqVar_SQUARED);\n  #form_arr = form_arr[form_arr != independendVar]\n}\nform_arr = form_arr[form_arr!=\"\"]\n#########################\n##  remove duplicates  ##\n#########################\n#take out duplicate variables\nform_arr = form_arr[!duplicated(form_arr)]\nformulastr = paste(dependendVar,\" ~ \",paste(form_arr,collapse='+'))\n#get variables involve in the formula\nvarList = all.vars(as.formula(formulastr));\n\n##**added\n# varList.independent = varList[-1]\nif (length(varList) > 0){ \n  varList.independent = varList[-1]\n}else {\n  varList.independent = \"\";\n}\n\n#trigger.warning = F\n#take out duplicated variables according to their values\nif(length(varList.independent)>1){\n  var.combin = combn(varList.independent,2)\n  identical.values = c()\n  for(ii in 1:ncol(var.combin)){\n    vars_i = var.combin[,ii]\n    #if two variables perfectly correlated, store both variables\n    if(cor(as.numeric(data[,vars_i[1]]),as.numeric(data[,vars_i[2]]), use = \"complete.obs\") %in% c(1,-1)){\n      # identical.values[ii] = list(vars_i)\n      identical.values = c(identical.values,list(vars_i))\n    }\n  }\n  vars.duplicate.remove = c()\n  if(length(identical.values) > 0){\n    for(ii in 1:length(identical.values)){\n      vars_both_i = identical.values[[ii]]\n      #if independendVar is in vars_both, remove other variable, otherwise doesn't matter which is removed\n      if(independendVar %in% vars_both_i){\n        vars.duplicate.remove[ii] = vars_both_i[vars_both_i != independendVar]\n      } else{\n        vars.duplicate.remove[ii] = vars_both_i[2]\n      }\n    }\n    trigger.warning = T\n    warning.duplicates = paste0(\"perfectly correlated variables detected, removed variable '\", vars.duplicate.remove, \"'\")\n    form_arr = form_arr[!form_arr %in% vars.duplicate.remove]\n    formulastr = paste(dependendVar,\" ~ \",paste(form_arr,collapse='+'))\n    varList = all.vars(as.formula(formulastr));\n    varList.independent = varList[-1]\n  }\n}\n\nprint(varList)\nprint(formulastr)\n\n#########################\n##  data manipulation  ##\n#########################\n#data = data[data$eventname == \"baseline_year_1_arm_1\",]\n# print(summary(data[[independendVar]]))\n#if independent variable has 5 or less unique values change it to character\/factor variable\n# categorical.independent = FALSE\n#if( length(table(data[[independendVar]])) < 6 ){\n#  data[[independendVar]] = as.character(data[[independendVar]])\n#  categorical.independent = TRUE\n#} else{\n#  data[[independendVar]] = as.numeric(as.character(data[[independendVar]]))\n#}\n\n# if(class(data[[independendVar]]) != \"numeric\"){\n#   categorical.independent = TRUE\n# }\n\n#user defined covariates\n#for(ucov in unlist(inputs[['usercov.']])){\n#  data[[ucov]] = as.numeric(as.character(data[[ucov]]))\n#}\n\n# print(summary(data[[independendVar]]))\n# #determine if logistic regression or not\n# categorical.dependent = FALSE\n# data[[dependendVar]][data[[dependendVar]] == \"\"] = NA\n# if( length(table(data[[dependendVar]])) == 2 ){\n#   data[[dependendVar]] = as.factor(data[[dependendVar]])\n#   categorical.dependent = TRUE\n# } else{\n#   data[[dependendVar]] = as.numeric(as.character(data[[dependendVar]]))\n# }\n#data[[dependendVar]] = as.numeric(as.character(data[[dependendVar]]))\n\n#if(\"demo_prnt_marital_v2\" %in% colnames(data)){\n# Type of household\n# 1 = Married, 6 = Living with a partner\n# 2 = Widowed, 3 = Divorced, 4 = Separated, 5 = Never married\n#  marital_v2.old = data$demo_prnt_marital_v2\n#  data$demo_prnt_marital_v2 = NA\n#  data$demo_prnt_marital_v2[marital_v2.old %in% c(1,6)] = 1\n#  data$demo_prnt_marital_v2[marital_v2.old %in% 2:5] = 0\n#}\n\n# if(\"gender\" %in% colnames(data)){\n#   data = data[data$gender %in% c(\"M\",\"F\"),]\n# }\n#if(\"race.ethnicity\" %in% colnames(data)){\n#  data$race.ethnicity = as.factor(data$race.ethnicity)\n#}\n#income\n##NDA using demo_prtnr_income_v2\n#if(\"demo_comb_income_v2\" %in% colnames(data)){\n#  data$hhinc = NA\n#  data$hhinc[data$demo_comb_income_v2 %in% 1:6]  = \"[<50K]\"\n#  data$hhinc[data$demo_comb_income_v2 %in% 7:8]  = \"[>=50K&<100K]\"\n#  data$hhinc[data$demo_comb_income_v2 %in% 9:10] = \"[>=100K]\"\n#  data$demo_comb_income_v2 = data$hhinc\n#}\nif(\"household.income.bl\" %in% names(data)){\n  data$household.income.bl = as.character(data$household.income.bl)\n  data$household.income.bl[data$household.income.bl == \"[>=50K & <100K]\"] = \"[>=50K& <100K]\"\n  data$household.income.bl = as.factor(data$household.income.bl)\n}\n\n\n\n#data = data[c(\"src_subject_id\",\"rel_family_id\",\"abcd_site\",varList)]\n\n#**added\ntype_imaging = NULL\nif(is.null(data[[dependendVar]])){\n  type_imaging = \"dependendVar\";\n} else if (is.null(data[[independendVar]])){\n  type_imaging = \"independendVar\";\n}\n\nprint(type_imaging)\n\nif(type_imaging == \"dependendVar\"){\n  data = data[c(\"src_subject_id\",\"rel_family_id\",\"abcd_site\",varList.independent)]\n  print(varList.independent)\n}\n\nif(type_imaging == \"independendVar\"){\n  data = data[c(\"src_subject_id\",\"rel_family_id\",\"abcd_site\",dependendVar,varList.independent)]\n}\n\n##################\n##  subset data ##\n##################\nif(length(subsetVar)>0){\n  json_data = rjson::fromJSON(file = subsetVar);\n  subset = data.frame(src_subject_id=unlist(lapply(json_data[[1]]$set,function(d){ d[1] })), eventname=unlist(lapply(json_data[[1]]$set,function(d){d[2]})));\n  data = merge(subset, data, all.x = T, all.y = F)\n}\n\n\n##################################################\n##  identify variables of different timepoints  ##\n##################################################\n\n#**may want to remove\n####before complete.cases, need to figure out which variables are in which events, and potentially transform\n\n\n# var.timepoints.with.data = matrix(NA, nrow = length(varList), ncol =  length(unique(data$eventname))+1)\n# var.timepoints.with.data[,1] = varList\n#var.timepoints.with.data = list()\n#for(ii in 1:length(varList)){\n#  var_i = varList[ii]\n#  if(var_i %in% names(data)){\n#    valid.data.per.timepoint = aggregate(data[var_i], list(data$eventname), function(x)sum(!is.na(x)))\n#    timepoints.with.data = as.character(valid.data.per.timepoint$Group.1[valid.data.per.timepoint[var_i] != 0])\n#    # var.timepoints.with.data[ii,(1:length(timepoints.with.data))+1] = timepoints.with.data\n#    var.timepoints.with.data[[ii]] = timepoints.with.data\n#  }\n#}\n#n.timepoints.per.var = unlist(lapply(var.timepoints.with.data,length))\n#\n#dep.timepoints = unlist(var.timepoints.with.data[dependendVar == varList])\n#indep.timepoints = unlist(var.timepoints.with.data[independendVar == varList])\n#\n##if DEPENDENT is follow-up only (no baseline visits), and INDEPENDENT is baseline only, shift DEPENDENT rows to baseline\n#if(sum(dep.timepoints != \"baseline_year_1_arm_1\") >= 1 & sum(dep.timepoints == \"baseline_year_1_arm_1\") == 0 & \n#   sum(indep.timepoints != \"baseline_year_1_arm_1\") == 0 & sum(indep.timepoints == \"baseline_year_1_arm_1\") == 1){\n#  \n#  data.dep = data[data$eventname == dep.timepoints , c(\"src_subject_id\",\"eventname\",dependendVar)]\n#  data.dep$eventname[data.dep$eventname == dep.timepoints] = indep.timepoints\n#  data[[dependendVar]] = NULL\n#  data = merge(data, data.dep, by = c(\"src_subject_id\",\"eventname\"), all = T)\n#}\n\n###################################################\n\n\ndata = data[complete.cases(data),]\n\nprint(dim(data))\n\n###################################################\n##  remove columns from model if 1 unique value  ##\n###################################################\n\n#less.than.2.levels = sapply(data , function(x) length(unique(x)) ) < 2\nvarList.in.data = names(data)[names(data) %in% varList]\nless.than.2.levels = sapply(data[varList.in.data] , function(x) length(unique(x)) ) < 2\n\n#trigger.warning = F\nif(sum(less.than.2.levels) >0 ){\n  trigger.warning = T\n  #vars.to.remove = names(data)[less.than.2.levels]\n  vars.to.remove = names(less.than.2.levels)[less.than.2.levels]\n  \n  \n  #stop script if dependent variable has less than 2 unique values\n  if(dependendVar %in% vars.to.remove){\n    stop(paste0(\"'\", dependendVar,\"'\" ,\" variable has <2 unique values\"))\n  }\n  if(independendVar %in% vars.to.remove){\n    stop(paste0(\"'\", independendVar,\"'\" ,\" variable has <2 unique values\"))\n  }\n  \n  #remove vars.to.remove from form_arr, formulastr, varList, and varList.independent\n  form_arr = form_arr[!form_arr %in% vars.to.remove]\n  formulastr = paste(dependendVar,\" ~ \",paste(form_arr,collapse='+'))\n  \n  varList = all.vars(as.formula(formulastr));\n  varList.independent = varList[-1]\n  \n  warning.1.unique.value = paste0(\"'\", vars.to.remove,\"'\" ,\" variable has <2 unique values - removed from model\")\n}\n\n########################################################################\n##  remove independendVar (& groupVar) from formula to get delta R^2  ##\n########################################################################\n\nrun.effect.size = T\n\nif(run.effect.size){\n  \n  \n  logVar.stripped    = substring(logVar,5,nchar(logVar)-1)\n  smoothVar.stripped = substring(smoothVar,3,nchar(smoothVar)-1)\n  \n  if(length(interactionVar)>0){\n    ##INTERACTION\n    interaction.stripped.list = strsplit(interactionVar,\"*\",fixed=T)\n  } else{\n    interaction.stripped.list = character()\n  }\n  \n  \n  if(independendVar %in% smoothVar.stripped){\n    ##SMOTH\n    smoothVar.remove = smoothVar[smoothVar.stripped == independendVar]\n    form_arr2 = form_arr[!(form_arr %in% smoothVar.remove)]\n  } else if(independendVar %in% smoothVarInt.stripped.term1){\n    ##SMOTH INTERACTION\n    smoothVarInt.remove = smoothVarInt[smoothVarInt.stripped.term1 == independendVar]\n    form_arr2 = form_arr[!(form_arr %in% smoothVarInt.remove)]\n  } else if(independendVar %in% logVar.stripped){\n    ##LOG\n    logVar.remove = logVar[logVar.stripped == independendVar]\n    form_arr2 = form_arr[!(form_arr %in% logVar.remove)]\n    if(length(groupVar)>0){\n      logVarinteraction.remove = c(paste0(logVar.remove,\"*\",groupVar) , groupVar)\n      form_arr2 = form_arr2[!(form_arr2 %in% logVarinteraction.remove)]\n    }\n  } else if(independendVar %in% sqVar){\n    ##SQUARED\n    sqVar.remove = c(independendVar, paste0(independendVar,\"_SQUARED\"))\n    form_arr2 = form_arr[!(form_arr %in% sqVar.remove)]\n    if(length(groupVar)>0){\n      sqVarinteraction.remove = c(paste0(sqVar.remove,\"*\",groupVar), groupVar)\n      form_arr2 = form_arr2[!(form_arr2 %in% sqVarinteraction.remove)]\n    }\n  } else if(independendVar %in% unlist(interaction.stripped.list)){\n    ##INTERACTION\n    independ.location = c()\n    for(ii in 1:length(interaction.stripped.list)){\n      int.stripped.list_i = interaction.stripped.list[[ii]]\n      independ.location[ii] = sum(independendVar == int.stripped.list_i)\n    }\n    interaction.remove = interactionVar[independ.location == 1]\n    interactionVars.remove = unlist(strsplit(interaction.remove,\"*\",fixed=T))\n    all.interactionVars.remove = c(interaction.remove,interactionVars.remove)\n    form_arr2 = form_arr[!(form_arr %in% all.interactionVars.remove)]\n  } else {\n    #NO INDEPENDENT VAR TRANSFORMATION\n    form_arr2 = form_arr[!(form_arr %in% independendVar)]\n  }\n  \n  if(length(form_arr2) > 0){\n    formulastr2 = paste(dependendVar,\" ~ \",paste(form_arr2,collapse='+'))\n  } else{\n    formulastr2 = paste(dependendVar,\" ~ 1\")\n  }\n  \n  \n}\n\n########################################\n##  make sure log doesn\u2019t create NAs  ##\n########################################\n\n# if(length(logVar.stripped)>0){\n#   for(ii in 1:length(logVar.stripped)){\n#     min.log_i = min(data[[logVar.stripped[ii]]])\n#     if(min.log_i < 0)  \n#       data[[logVar.stripped[ii]]] = data[[logVar.stripped[ii]]] - min.log_i + 1\n#   }\n# }\n\n\n\nprint(\"Before calling the model\")\n\n\n\n######################\n##  random effects  ##\n######################\ninclude.random.scanner = \"mri_info_deviceserialnumber\" %in% unlist(inputs$rand.var)\ninclude.random.site    = \"abcd_site\" %in% unlist(inputs$rand.var)\ninclude.random.subject = \"src_subject_id\" %in% unlist(inputs$rand.var)\n\n#IF less than 2 unique \"eventname\" & \"include.random.subject\" toggled on, \n#   need to toggle off random subject effect and produce warning (or error)\nif(length(unique(data$eventname)) <2 & include.random.subject){\n  include.random.subject = FALSE\n  trigger.warning = T\n  warning.1.unique.eventname = paste0(\"Your model data contains a single data point per subject (event name \u201cbaseline_year_1_arm_1\u201d) only. To prevent problems with model convergence suggest to remove SUBJECT from the list of random effects. It is not required with this particular cross-sectional analysis.\")\n}\n#IF 2+ unique \"eventname\" & \"include.random.subject\" toggled off, \n#   need to toggle on random subject effect and produce warning (or error)\nif(length(unique(data$eventname)) > 1 & !include.random.subject){\n  # include.random.subject = TRUE\n  trigger.warning = T\n  warning.2.unique.eventname = paste0(\"Your model data contains multiple data points per subject (event name \u201cbaseline_year_1_arm_1\u201d). Suggest to include SUBJECT from the list of random effects.\")\n}\n\n\n\nformula.random.str = c()\nif(include.random.site & !include.random.subject){\n  formula.random.str = \"(1|abcd_site\/rel_family_id)\"\n} else if(include.random.scanner & !include.random.subject){\n  formula.random.str = \"(1|mri_info_deviceserialnumber\/rel_family_id)\"\n} else{\n  if(include.random.site) formula.random.str[1] = \"(1|abcd_site)\"\n  if(include.random.scanner) formula.random.str[1] = \"(1|mri_info_deviceserialnumber)\"\n  formula.random.str[2] = \"(1|rel_family_id)\"\n  if(include.random.subject) formula.random.str[3] = \"(1|src_subject_id)\"\n}\nformula.random.str = formula.random.str[!is.na(formula.random.str)]\nformula.random.str = paste0(\"~\",paste(formula.random.str, collapse = \"+\"))\nformula.random = formula.random.str\n\n\n###########################\n##  voxel-wise analysis  ##\n###########################\n\n#type_vox = NULL;\n\n#read in imaging data\nif(is.voxel.analysis){\n  if(type_imaging == \"dependendVar\"){\n    imageVar = dependendVar\n  } else if(type_imaging == \"independendVar\"){\n    imageVar = independendVar\n  }\n  vox_fl = list.files(path = \"\/var\/www\/html\/data\/ABCD\/Rds\/\", pattern = paste0(\"*\", imageVar ,\"*\"));\n  print(paste0(\"*\",imageVar,\"*\"))\n  print(vox_fl)\n  print(class(vox_fl))\n  print(vox_fl[0])\n  if( length(vox_fl) != 2){\n    vox_fl = list.files(path = \"\/var\/www\/html\/data\/ABCD\/Rds\/\",pattern = \"*.Rds\");\n    vox_fl_msg = paste(vox_fl, sep = \",\\n\", collapse=\",\\n\")\n    stop(paste0(\"Cannot identify vertex data. These vox contrast available:\\n\", vox_fl_msg))\n  }\n}\n\nstatistics = list()\ntunnel = list()\n##################################################################\n\n###function to load and merge imaging data with Rds file\n###returns:\n### (1) names of image variables \n### (2) merged data\nload.and.merge.imaging.data = function(brain_side_j){\n  if(is.voxel.analysis){\n    path_body = '\/var\/www\/html\/data\/ABCD\/Rds\/'\n    print(paste(\"Loading: \", paste0(path_body, vox_fl[jj])))\n    data.image = readRDS(paste0(path_body, vox_fl[jj]))\n  } else if(is.roi.analysis){\n    side.of.brain.names = names(dat.image)[grepl( paste0(\".\", brain_side_j), names(dat.image),fixed=T)]\n    data.image = dat.image[,c(\"src_subject_id\",side.of.brain.names)]\n  }\n  image.vars = names(data.image[-1])\n  dat.all = merge(data , data.image, by = \"src_subject_id\" )\n  \n  if(exists(\"varList.independent\")){\n    varList.w.image.vars = c(varList.independent,image.vars)\n  } else{\n    varList.w.image.vars = image.vars\n  }\n  \n  dat.all.com = dat.all[complete.cases(dat.all[,varList.w.image.vars]) , ]\n  return(list(image.vars,dat.all.com))\n}\n\nSIDE.OF.BRAIN = c(\"lh\",\"rh\")\n#----------------------------------------------------------------------\n#--   perform imaging analysis\n#----------------------------------------------------------------------\n#-   independent image variables - model looping\nif(type_imaging == \"independendVar\"){\n  for(jj in 1:length(SIDE.OF.BRAIN)){\n    image.stuff = load.and.merge.imaging.data(SIDE.OF.BRAIN[jj])\n    image.vars = image.stuff[[1]] \n    dat.all.com = image.stuff[[2]]\n    \n    betas1 = c()\n    betas = c()\n    pvals = c()\n    data.loop = dat.all.com[,!names(dat.all.com) %in% image.vars]\n    print (paste(\"loop length is \",length(image.vars) ))\n    cl <- makeCluster(16)\n    registerDoParallel(16)\n    \n    N.image.vars = length(image.vars)\n    slist = foreach(ii= 1:N.image.vars , .combine=rbind) %dopar% {\n      print(ii)\n      data.loop$x = dat.all.com[, image.vars[ii]]\n      formula = paste0(formulastr2, \" + x\")\n      model.loop = gam(formula = as.formula(formula) ,  data = data.loop)\n      summary = as.data.frame(summary(model.loop)$p.table)\n      summary = as.data.frame(summary)\n      toJSON(digits = NA, unname(split(summary, 1:nrow(summary))))\n    }\n    print(length(slist))\n    \n    for(ii in 1:N.image.vars){\n      summary = fromJSON(slist[ii])\n      #betas1[ii] = summary[rownames(summary) == \"x\", colnames(summary) == \"Estimate\"]\n      betas1[ii] = as.numeric(summary[[length(summary)]][\"Estimate\"])\n      #pvals[ii] = summary[rownames(summary) == \"x\", colnames(summary) == \"Pr(>|t|)\"]\n      pvals[ii] = as.numeric(summary[[length(summary)]][\"Pr(>|t|)\"])\n      betas[ii] = -log10(pvals[ii]) * sign(betas1[ii]);\n    }\n    stopCluster(cl)\n    print(betas)\n    names(betas) = image.vars\n\n    tunnel[[ SIDE.OF.BRAIN[jj] ]] = betas\n  }\n}\n\n#----------------------------------------------------------------------\n#-   dependent image variables - matrix calculations\nif(type_imaging == \"dependendVar\"){\n  for(jj in 1:length(SIDE.OF.BRAIN)){\n    image.stuff = load.and.merge.imaging.data(SIDE.OF.BRAIN[jj])\n    image.vars = image.stuff[[1]] \n    dat.all.com = image.stuff[[2]]\n  \n    y1 = image.vars[1]\n    formulastr = paste(y1,\" ~ \",paste(form_arr,collapse='+'))\n    model.gam = gam(as.formula(formulastr) , data=dat.all.com)\n    M = model.matrix(model.gam)\n    \n    #----------------------------------------------------------------------\n    #---   PING matrix algebra to get coefficients\n    Mi = vcov(model.gam,dispersion=1)%*%t(M)  #    Mi = ginv(M)\n    C = Mi %*% t(Mi)\n    H = Mi %*% M\n    dof = sum(diag(H))\n    datamat = as.matrix(dat.all.com[,image.vars])\n    \n    coeffmat = Mi %*% datamat              #coefficients, each column is for a different dependent var\n    datamat_hat = M %*% coeffmat           #predicted values\n    errmat = (datamat_hat-datamat)^2       #squared residuals\n    dof.err = nrow(errmat)-dof             #degrees of freedom\n    sig2vec = colSums(errmat) \/ dof.err    #sigma^2: estimated variance of random error\n    termlist = colnames(M)\n    err_dev_full=sum(errmat)   #total error\n    #----------------------------------------------------------------------\n    indlists = list(grep(paste(glob2rx(paste(independendVar,\"*\",sep=\"\")),\"[^:]*$\",sep=\"\"),termlist,value=FALSE))\n    #indlists = list(grep(paste(glob2rx(paste(independent.variable,\"*\",sep=\"\")),\"[^:]*$\",sep=\"\"),termlist,value=FALSE))\n    \n    nvert = length(image.vars)\n    logpmat = matrix(NA,length(indlists),nvert)\n    \n    listi = 3;\n    if (TRUE) listi = 1\n    hemipvals  = vector(\"list\", listi); # list of vectors\n    log10pvals = vector(\"list\", listi); # list of list of vectors\n    \n    # hemispheres <- c(\"lh\", \"rh\")\n    \n    #if loops once, means no smooth term, otherwise  \n    #indlists will be longer than one with interaction term, or smooth term\n    for (listi in 1:length(indlists)) {\n      #location of 'x' variable in independent variables\n      indlist = indlists[[listi]]\n      \n      # Compute t- and p-values for each\n      if (length(indlist)==1) { # single-coefficient case (t-test)\n        sevec = sqrt(C[indlist,indlist]*sig2vec)\n        tvec = coeffmat[indlist,]\/sevec\n        pvec = 2*pt(-abs(tvec),df=dof.err)\n        \n        #hemipvals is vector of lists (length listi (which is 1 or 3), or length indlists (or both?))\n        hemipvals[[listi]] = append(hemipvals[[listi]], pvec);\n        logpvec = -log10(pvec)*sign(tvec)\n        log10pvals[[listi]] = logpvec;\n        # log10pvals[[listi]][[h]] = logpvec;\n        #h is hemispheres\n      }\n    }\n    #tunnel[[\"lh\"]] = coeffmat[dim(coeffmat)[1],];\n    tunnel[[ SIDE.OF.BRAIN[jj] ]] = log10pvals[[1]];\n    pmat = rbind(sevec, tvec, pvec)\n    \n    output.ind = 1:10\n    statistics[[ paste0(SIDE.OF.BRAIN[jj], \"_p\") ]]    = stargazer(pmat[,output.ind], type  = \"html\")\n    statistics[[ paste0(SIDE.OF.BRAIN[jj], \"_ptable\")]]= stargazer(coeffmat[,output.ind], type  = \"html\")\n  }  \n}\n\nscatter = list()\nlineplot = list()\n\noutput_log = NULL\n#########################################################################################################\n#########################################################################################################\n\n\n## old code below:\n\n# ## looping with image variables as independent\n# \n# if(type_vox == \"independendVar\"){\n#   \n#   path_body = '\/var\/www\/html\/data\/ABCD\/Rds\/'\n#   print(paste(\"Loading: \", paste0(path_body, vox_fl[1])))\n#   data.image = readRDS(paste0(path_body, vox_fl[1]))\n#   image.vars = names(data.image[-1])\n#   dat.all = merge(data , data.image, by = \"src_subject_id\" )\n#   varList.w.image.vars = c(varList.independent,image.vars)\n#   dat.all.com = dat.all[complete.cases(dat.all[,varList.w.image.vars]) , ]\n#   \n#   \n#   betas1 = c()\n#   betas = c()\n#   pvals = c()\n#   print(564); \n#   data.loop = dat.all.com[,!names(dat.all.com) %in% image.vars]\n#   print (paste(\"loop length is \",length(image.vars) ))\n#   cl <- makeCluster(16)\n#   registerDoParallel(16)\n#   \n#   \n#   slist = foreach(ii= 1:2565 , .combine=rbind) %dopar% {\n#     print(ii)\n#     data.loop$x = dat.all.com[, image.vars[ii]]\n#     formula = paste0(formulastr2, \" + x\")\n#     model.loop = gam(formula = as.formula(formula) ,  data = data.loop)\n#     summary = as.data.frame(summary(model.loop)$p.table)\n#     summary = as.data.frame(summary)\n#     toJSON(unname(split(summary, 1:nrow(summary))))\n#     \n#   }\n#   \n#   print(length(slist))\n#   \n#   \n#   for(ii in  1:2565){\n#     summary = fromJSON(slist[ii])\n#     #betas1[ii] = summary[rownames(summary) == \"x\", colnames(summary) == \"Estimate\"]\n#     betas1[ii] = as.numeric(summary[[length(summary)]][\"Estimate\"])\n#     #pvals[ii] = summary[rownames(summary) == \"x\", colnames(summary) == \"Pr(>|t|)\"]\n#     pvals[ii] = as.numeric(summary[[length(summary)]][\"Pr(>|t|)\"])\n#     betas[ii] = -log10(pvals[ii]) * sign(betas1[ii]);\n#   }\n#   stopCluster(cl)\n#   print(betas)\n#   tunnel[[\"lh\"]] = betas\n#   \n#   \n#   path_body = '\/var\/www\/html\/data\/ABCD\/Rds\/'\n#   print(paste(\"Loading: \", paste0(path_body, vox_fl[2])))\n#   data.image = readRDS(paste0(path_body, vox_fl[2]))\n#   image.vars = names(data.image[-1])\n#   dat.all = merge(data , data.image, by = \"src_subject_id\" )\n#   varList.w.image.vars = c(varList.independent,image.vars)\n#   dat.all.com = dat.all[complete.cases(dat.all[,varList.w.image.vars]) , ]\n#   \n#   betas1 = c()\n#   betas = c()\n#   pvals = c()\n#   print(564); \n#   data.loop = dat.all.com[,!names(dat.all.com) %in% image.vars]\n#   print (paste(\"loop length is \",length(image.vars) ))\n#   cl <- makeCluster(16)\n#   registerDoParallel(16)\n#   \n#   \n#   slist = foreach(ii= 1:2565 , .combine=rbind) %dopar% {\n#     print(ii)\n#     data.loop$x = dat.all.com[, image.vars[ii]]\n#     formula = paste0(formulastr2, \" + x\")\n#     model.loop = gam(formula = as.formula(formula) ,  data = data.loop)\n#     summary = as.data.frame(summary(model.loop)$p.table)\n#     toJSON(unname(split(summary, 1:nrow(summary))))\n#     \n#   }\n#   \n#   print(length(slist))\n#   \n#   \n#   for(ii in  1:2565){\n#     summary = fromJSON(slist[ii])\n#     #print(slist[ii])\n#     #betas1[ii] = summary[rownames(summary) == \"x\", colnames(summary) == \"Estimate\"]\n#     betas1[ii] = as.numeric(summary[[length(summary)]][\"Estimate\"])\n#     #pvals[ii] = summary[rownames(summary) == \"x\", colnames(summary) == \"Pr(>|t|)\"]\n#     pvals[ii] = as.numeric(summary[[length(summary)]][\"Pr(>|t|)\"])\n#     betas[ii] = -log10(pvals[ii]) * sign(betas1[ii]);\n#   }\n#   stopCluster(cl)\n#   tunnel[[\"rh\"]] = betas\n#   print(betas)\n# }\n# \n# \n# \n# ########################## Run a single column test ################################\n# \n# \n# #########################################################################\n# if(type_vox == \"dependendVar\"){\n#   #use first image variable to create model matrix\n#   \n#   path_body = '\/var\/www\/html\/data\/ABCD\/Rds\/'\n#   print(paste(\"Loading: \", paste0(path_body, vox_fl[1])))\n#   data.image = readRDS(paste0(path_body, vox_fl[1]))\n#   image.vars = names(data.image[-1])\n#   varList.w.image.vars = c(varList.independent,image.vars)\n#   dat.all = merge(data , data.image, by = \"src_subject_id\" )\n#   dat.all.com = dat.all[complete.cases(dat.all[,varList.w.image.vars]) , ]\n#   \n#   \n#   y1 = image.vars[1]\n#   formulastr = paste(y1,\" ~ \",paste(form_arr,collapse='+'))\n#   model.gam = gam(as.formula(formulastr) , data=dat.all.com)\n#   M = model.matrix(model.gam)\n#   \n#   print(\"line 574\\n\");\n#   \n#   #PING matrix algebra to get coefficients\n#   Mi = vcov(model.gam,dispersion=1)%*%t(M)  #    Mi = ginv(M)\n#   C = Mi %*% t(Mi)\n#   H = Mi %*% M\n#   dof = sum(diag(H))\n#   datamat = as.matrix(dat.all.com[,image.vars])\n#   #coefficients, each column is for a different dependent var\n#   coeffmat = Mi %*% datamat\n#   #predicted values\n#   datamat_hat = M %*% coeffmat\n#   #squared residuals\n#   errmat = (datamat_hat-datamat)^2\n#   #degrees of freedom\n#   dof.err = nrow(errmat)-dof\n#   #sigma^2: estimated variance of random error\n#   sig2vec = colSums(errmat) \/ dof.err\n#   termlist = colnames(M)\n#   #total error\n#   err_dev_full=sum(errmat)\n#   \n#   print(\"line 594\\n\");\n#   \n#   indlists = list(grep(paste(glob2rx(paste(independendVar,\"*\",sep=\"\")),\"[^:]*$\",sep=\"\"),termlist,value=FALSE))\n#   # indlists = list(grep(paste(glob2rx(paste(independent.variable,\"*\",sep=\"\")),\"[^:]*$\",sep=\"\"),termlist,value=FALSE))\n#   \n#   nvert = length(image.vars)\n#   logpmat = matrix(NA,length(indlists),nvert)\n#   \n#   listi = 3;\n#   # if (smoothing.interaction == \"\") \n#   if (TRUE) listi = 1\n#   hemipvals  = vector(\"list\", listi); # list of vectors\n#   log10pvals = vector(\"list\", listi); # list of list of vectors\n#   \n#   # hemispheres <- c(\"lh\", \"rh\")\n#   \n#   #if loops once, means no smooth term, otherwise  \n#   #indlists will be longer than one with interaction term, or smooth term\n#   for (listi in 1:length(indlists)) {\n#     #location of 'x' variable in independent variables\n#     indlist = indlists[[listi]]\n#     \n#     # Compute t- and p-values for each\n#     if (length(indlist)==1) { # single-coefficient case (t-test)\n#       sevec = sqrt(C[indlist,indlist]*sig2vec)\n#       tvec = coeffmat[indlist,]\/sevec\n#       pvec = 2*pt(-abs(tvec),df=dof.err)\n#       \n#       #hemipvals is vector of lists (length listi (which is 1 or 3), or length indlists (or both?))\n#       hemipvals[[listi]] = append(hemipvals[[listi]], pvec);\n#       logpvec = -log10(pvec)*sign(tvec)\n#       log10pvals[[listi]] = logpvec;\n#       # log10pvals[[listi]][[h]] = logpvec;\n#       #h is hemispheres\n#     }\n#   }\n#   \n#   #tunnel[[\"lh\"]] = coeffmat[dim(coeffmat)[1],];\n#   tunnel[[\"lh\"]] = log10pvals[[1]];\n#   \n#   pmat = rbind(sevec, tvec, pvec)\n#   statistics[[\"lh_p\"]] =   stargazer(pmat[,seq(1,2500,by=150)], type  = \"html\")\n#   \n#   statistics[[\"ptable\"]] = stargazer(coeffmat[,seq(1,2500,by=150)], type  = \"html\")\n#   \n#   #####################################################\n#   #####################################################\n#   \n#   path_body = '\/var\/www\/html\/data\/ABCD\/Rds\/'\n#   print(paste(\"Loading: \", paste0(path_body, vox_fl[2])))\n#   data.image = readRDS(paste0(path_body, vox_fl[2]))\n#   image.vars = names(data.image[-1])\n#   dat.all = merge(data , data.image, by = \"src_subject_id\" )\n#   dat.all.com = dat.all[complete.cases(dat.all[,varList.w.image.vars]) , ]\n#   \n#   \n#   #use first image variable to create model matrix\n#   y1 = image.vars[1]\n#   formulastr = paste(y1,\" ~ \",paste(form_arr,collapse='+'))\n#   model.gam = gam(as.formula(formulastr) , data=dat.all.com)\n#   M = model.matrix(model.gam)\n#   \n#   #PING matrix algebra to get coefficients\n#   Mi = vcov(model.gam,dispersion=1)%*%t(M)  #    Mi = ginv(M)\n#   C = Mi %*% t(Mi)\n#   H = Mi %*% M\n#   dof = sum(diag(H))\n#   datamat = as.matrix(dat.all.com[,image.vars])\n#   #coefficients, each column is for a different dependent var\n#   coeffmat = Mi %*% datamat\n#   #predicted values\n#   datamat_hat = M %*% coeffmat\n#   #squared residuals\n#   errmat = (datamat_hat-datamat)^2\n#   #degrees of freedom\n#   dof.err = nrow(errmat)-dof\n#   #sigma^2: estimated variance of random error\n#   sig2vec = colSums(errmat) \/ dof.err\n#   termlist = colnames(M)\n#   #total error\n#   err_dev_full=sum(errmat)\n#   \n#   \n#   \n#   indlists = list(grep(paste(glob2rx(paste(independendVar,\"*\",sep=\"\")),\"[^:]*$\",sep=\"\"),termlist,value=FALSE))\n#   # indlists = list(grep(paste(glob2rx(paste(independent.variable,\"*\",sep=\"\")),\"[^:]*$\",sep=\"\"),termlist,value=FALSE))\n#   \n#   nvert = length(image.vars)\n#   logpmat = matrix(NA,length(indlists),nvert)\n#   \n#   listi = 3;\n#   # if (smoothing.interaction == \"\") \n#   if (TRUE) listi = 1\n#   hemipvals  = vector(\"list\", listi); # list of vectors\n#   log10pvals = vector(\"list\", listi); # list of list of vectors\n#   \n#   # hemispheres <- c(\"lh\", \"rh\")\n#   \n#   #if loops once, means no smooth term, otherwise  \n#   #indlists will be longer than one with interaction term, or smooth term\n#   for (listi in 1:length(indlists)) {\n#     #location of 'x' variable in independent variables\n#     indlist = indlists[[listi]]\n#     \n#     # Compute t- and p-values for each\n#     if (length(indlist)==1) { # single-coefficient case (t-test)\n#       sevec = sqrt(C[indlist,indlist]*sig2vec)\n#       tvec = coeffmat[indlist,]\/sevec\n#       pvec = 2*pt(-abs(tvec),df=dof.err)\n#       \n#       #hemipvals is vector of lists (length listi (which is 1 or 3), or length indlists (or both?))\n#       hemipvals[[listi]] = append(hemipvals[[listi]], pvec);\n#       logpvec = -log10(pvec)*sign(tvec)\n#       log10pvals[[listi]] = logpvec;\n#       # log10pvals[[listi]][[h]] = logpvec;\n#       #h is hemispheres\n#     }\n#   }\n#   \n#   #tunnel = list();\n#   tunnel[[\"rh\"]] = log10pvals[[1]];\n#   #tunnel[[\"rh\"]] = coeffmat[dim(coeffmat)[1],];\n#   \n#   \n# }\n# \n# scatter = list()\n# lineplot = list()\n\n"}],"screen-position":{"top":239,"left":1239},"gid":"73d0ca37-205c-4c90-a4de-8d63074a31d4","enabledisable-id":"5c2cc7b6-5701-49e5-ba26-c01095225f7f"},{"name":"Measure Fixed","id":"measure-fixed","group":"Input","description":"input","inputs":[],"outputs":[{"name":"out","type":"constant-text","id":"0e65291a-9675-49c4-9641-f47116bd25de"}],"state":[{"name":"id","type":"text","gid":"16659353-018d-40bc-b005-57bf46566cbd","value":"weight.var"},{"name":"name","type":"text","gid":"16659353-018d-40bc-b005-57bf46566cbd","value":"Propensity Weight"},{"name":"default","type":"text","gid":"16659353-018d-40bc-b005-57bf46566cbd","value":"true"},{"name":"value","type":"text","gid":"16659353-018d-40bc-b005-57bf46566cbd","value":"NDA17"}],"screen-position":{"left":374,"top":280},"gid":"16659353-018d-40bc-b005-57bf46566cbd","enabledisable-id":"ff22599b-9cbc-4c93-8e8a-406f93a4ca1f"}],"connections":[{"id":"0fce2d50-0193-40b9-be47-3108de9a28a1","source":"port-output-1ba4c758-4cd7-4bfe-8870-8588f311c769","target":"port-input-64de6011-ff94-4b30-8568-fec371dd6804","source-side":"right","target-side":"left"},{"id":"5a631626-c8c4-41b8-bd45-3da951f14ef1","source":"port-output-ced51cbb-abb4-45c3-a5e3-d4fa06cc6cc3","target":"port-input-d0b1e6c6-2e95-4e3a-badf-ce0051dbbf53","source-side":"right","target-side":"left"},{"id":"05a62d81-aa1a-4488-88ff-2f5efe38288e","source":"port-output-dfb15146-bb00-4655-858c-62ccec593001","target":"port-input-e9dfd108-c1e1-4b85-b50b-eb3b27dc6394","source-side":"right","target-side":"left"},{"id":"a590877a-e98b-46ab-a5a4-8873501a3b29","source":"port-output-3226f90e-a1ea-4e78-8772-8fa60a49eac4","target":"port-input-64de6011-ff94-4b30-8568-fec371dd6804","source-side":"right","target-side":"left"},{"id":"710ca707-c82b-4091-aa99-2ab2ce7ca684","source":"port-output-f046675d-5841-44cb-ab5e-60912f5c179a","target":"port-input-64de6011-ff94-4b30-8568-fec371dd6804","source-side":"right","target-side":"left"},{"id":"be3f5682-fca9-4c8b-9de4-a4ce318255bd","source":"port-output-3c06fa2a-5479-49f3-b1c9-fe1098420a57","target":"port-input-64de6011-ff94-4b30-8568-fec371dd6804","source-side":"right","target-side":"left"},{"id":"582a0871-4e00-4023-9bb0-60107ad2e0a9","source":"port-output-dfbdf064-5cf5-4087-b73f-e093fb340c12","target":"port-input-64de6011-ff94-4b30-8568-fec371dd6804","source-side":"right","target-side":"left"},{"id":"3a2b1fdb-aab7-49f7-9e7a-20c2c1998075","source":"port-output-a090b405-f3af-4655-8706-24634c69200b","target":"port-input-64de6011-ff94-4b30-8568-fec371dd6804","source-side":"right","target-side":"left"},{"id":"b9e94f57-2760-40d0-8665-6375635a5ca8","source":"port-output-b0b845c1-9494-462b-882a-b97383400416","target":"port-input-058032eb-2a92-4698-b090-6b4b68524055","source-side":"right","target-side":"left"},{"id":"5f0f4dc7-797b-499a-ada1-95403cacd04b","source":"port-output-10c3487e-51ff-4862-b3d0-226fd4107478","target":"port-input-5467c3d0-18ad-42e6-b472-f549b56c62b7","source-side":"right","target-side":"left"},{"id":"94326d14-af44-4bbc-8897-37aefb423765","source":"port-output-aa991afb-edc4-4854-8c3c-b2ecf6c5b3da","target":"port-input-cda34d74-af74-41f3-9da3-b93c4f042af7","source-side":"right","target-side":"left"},{"id":"80fa551d-c0c7-4f36-965d-b4dc86a03cf1","source":"port-output-80b11404-28a4-43c9-a6b7-cc68362af908","target":"port-input-cda34d74-af74-41f3-9da3-b93c4f042af7","source-side":"right","target-side":"left"},{"id":"f20d5019-1784-4c8b-8b0f-a96df627c6e2","source":"port-output-60b3ed6f-23ca-4bd0-be3d-e1879fd6fe16","target":"port-input-cda34d74-af74-41f3-9da3-b93c4f042af7","source-side":"right","target-side":"left"},{"id":"b0775852-4bdc-41d9-a594-8b35b867262b","source":"port-output-5533ca80-de45-4d4b-9da9-e8f85ff30a57","target":"port-input-cda34d74-af74-41f3-9da3-b93c4f042af7","source-side":"right","target-side":"left"},{"id":"c6f284c9-2422-4655-9c9a-33c82714d85c","source":"port-output-c28a88a5-17f7-4302-8899-e7f506a471a1","target":"port-input-64de6011-ff94-4b30-8568-fec371dd6804","source-side":"right","target-side":"left"},{"id":"c3e7822d-2f56-4eaf-aeec-5ad6114d152f","source":"port-output-bafe1270-7036-41b2-bf47-57f3f6404614","target":"port-input-3b4cc89d-9514-489a-a844-4a66c02675dc","source-side":"right","target-side":"left"},{"id":"6a3d1a56-ef6f-40cf-a1d3-76b7ff1a5dab","source":"port-output-05bad52b-5789-4e5c-9e9e-c7c469f3a93e","target":"port-input-26486264-8eb2-4942-85d5-9d1de60d1c41","source-side":"right","target-side":"left"},{"id":"0227a0e3-c7a6-4e47-b4a9-cd8baf07b8f4","source":"port-output-049c008e-3e9f-43fb-bb41-0eefbf4937b8","target":"port-input-35b173e3-0070-43c3-bbf5-d86afd8c194a","source-side":"right","target-side":"left"},{"id":"9d19b066-133e-4518-93ca-53c4b82275d0","source":"port-output-fffb4252-410a-4b9e-82e7-323d0c8ca46d","target":"port-input-5bb4718f-4031-4cd7-a20f-d01f833d122b","source-side":"right","target-side":"left"},{"id":"1007843e-5090-4e9a-8688-5dae47b59587","source":"port-output-08ddaa6d-2c77-4ade-ad36-d04596416214","target":"port-input-5baa8968-e52e-41a8-ab8a-2014d3c1626b","source-side":"right","target-side":"left"},{"id":"1266a473-9e6e-418e-9b61-440993fec86b","source":"port-output-28b12798-18bf-4a96-a27d-36c70120d0f6","target":"port-input-d88cb788-2081-422d-ad93-52f520ad52af","source-side":"right","target-side":"left"},{"id":"bd36a5ac-0317-4253-9121-624ce80652d5","source":"port-output-49e486ad-699c-412f-963c-d1ec0709cff9","target":"port-input-6851aad2-cda1-4047-b45a-48b604500cb0","source-side":"right","target-side":"left"},{"id":"0f25ab13-6cbf-44d5-8271-29d38e968fdc","source":"port-output-a7cc9f44-4879-4118-b0ab-51f8e6169502","target":"port-input-176a97bd-4a9b-4a84-bf62-cffa66c78d0f","source-side":"right","target-side":"left"},{"id":"a0be3db8-dd2e-4c52-84ce-a4f675cf6f01","source":"port-output-f6a6c305-7219-4be4-88d5-e8875da3ce11","target":"port-input-59afa45a-6816-4ae0-be64-1e5afd27e98f","source-side":"right","target-side":"left"},{"id":"81c76960-ab28-4421-955f-2e7abf1b40e6","source":"port-output-6825b4df-6c7a-4d59-801c-f0bb2b52f327","target":"port-input-90f25d94-bb14-4c95-9ee0-623355c2eeb5","source-side":"right","target-side":"left"},{"id":"647d0e69-aba4-41e2-af2f-70822c2293e8","source":"port-output-3ea903f2-93d1-4fa4-86a3-63e62e54bc59","target":"port-input-0c02bfa9-50d8-434c-806d-e31db3b329a0","source-side":"right","target-side":"left"},{"id":"939dc834-7b5d-48e1-be9c-07ff1d649b1f","source":"port-output-1b27adc4-cdff-412c-872e-eef2f3b45f62","target":"port-input-ae106892-c760-4b24-a0f4-f03b62aa7753","source-side":"right","target-side":"left"},{"id":"00438f6a-3248-4f49-b28b-2886eff281bb","source":"port-output-55db9226-77e7-4d5e-a940-603786490cc9","target":"port-input-d2ff5368-b2ee-4325-81e7-936254f697cd","source-side":"right","target-side":"left"},{"id":"16c5f8db-e3d7-4cae-b2c5-14dfd7ab0bab","source":"port-output-a0f7e069-92c5-4466-97b6-8246c6e98500","target":"port-input-e376616d-2f95-408c-b225-860d270247e1","source-side":"right","target-side":"left"},{"id":"b23cfda5-2e8f-4968-be01-98ddb1c60ca0","source":"port-output-209b8148-ea1c-4ec9-8b68-da88a43d9d8c","target":"port-input-cc9e7950-f3b2-4a30-8446-456a05a22ffa","source-side":"right","target-side":"left"},{"id":"7ba0713e-14c7-4abc-b705-4d01b3162c45","source":"port-output-e2c610a7-093b-4f75-9bc6-2c587125ea34","target":"port-input-62b02bc1-048f-43b2-8586-8fb643b1ee6b","source-side":"right","target-side":"left"},{"id":"85f2febc-2fc5-4d52-aee0-0f8764e718bb","source":"port-output-d2dc7279-8eec-4f52-afca-c62d40486fd0","target":"port-input-caab4d31-ae0f-4638-9c19-79863c170fcf","source-side":"right","target-side":"left"},{"id":"a9bc0333-940e-4177-8f32-d9552d6f5035","source":"port-output-0e65291a-9675-49c4-9641-f47116bd25de","target":"port-input-cf378cc2-5c7d-4096-9b3c-44e6eedf43b2","source-side":"right","target-side":"left"}],"description":"","envelope":[{"lastSavedByUserName":"admin","lastSavedByUserEmail":"","lastSaveAtDate":"2020-03-19T14:12:52-07:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-17T13:36:47-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-17T12:26:04-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-17T12:14:07-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-17T12:03:11-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-17T12:01:08-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-17T11:59:58-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-17T11:55:02-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-17T11:44:26-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-17T11:41:05-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-17T11:39:11-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-09T11:44:03-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-09T11:17:37-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-09T11:14:40-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-09T11:08:05-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-06T13:14:00-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-06T13:06:47-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-06T13:06:09-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-06T10:34:30-08:00"},{"lastSavedByUserName":"chasereuter1","lastSavedByUserEmail":"","lastSaveAtDate":"2019-12-06T10:33:49-08:00"}]}