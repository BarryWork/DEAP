{"content":"\"### Split age into two categories\\nThis is an example score calculation that shows how to dichotomize a measure. In this case we split the age variable which is given in \\nmonth into two arbitrary categories $\\\\mbox{age}<120$ and $\\\\mbox{age}\\\\geq120$. \\n\\nFor this computation we need to get the variable called <code>age<\/code>. You can find the name of this variable in the Explore \\napplication. We can pull the variable into our table for this computation by calling the function <code>use()<\/code>. The brackets \\nnotation allows us to use more than one variable, but just writing <code>use(\\\"age\\\")<\/code> would also be sufficient.\\n```\\nvar promise = use([\\\"age\\\"]);\\n```\\nThe <code>use<\/code>-function might need some time retrieving the values for us from the DEAP server. Our program will not wait\\nat this place until the values are ready for us. Instead the function will return us a _promise_ that at some later point we will get the values\\nfrom the server. This is an example of asynchronous computation because while the server is getting us our data we could be doing\\nsomething else here. Like defining our function <code>calcDichot<\/code>.\\n\\nThis function will return the value 1 or 0 dependent on the actual age value provided as an argument.\\n```\\nfunction calcDichot(age) {\\n    if (age > 120)\\n        return 1;\\n    return 0;\\n}\\n```\\n\\nNow we are ready to call our <code>calcDichot<\/code> function for each of the participants age variables. But first we have to make sure \\nthat the server fulfilled the promise. This is done using a special promise processing function <code>Promise.all()<\/code>. We provide our\\nvariable _promise_ as an argument to <code>all()<\/code> and we can specify with <code>then()<\/code> that once the promises are fulfilled\\nwe want to run an unnamed function provided as an argument to <code>then()<\/code>. \\n```\\nPromise.all(promise).then( function() {\\n  var data = new DataFrame(allMeasures);\\n  data = data.map(row => row.set('age_dichot', calcDichot(row.get('age'))));\\n  update(data, 'age_dichot');\\n});\\n```\\n\\nInside this function we have three lines. The first line returns a handle to the data table with all the data we have \\nreceived from the server. The last line updates the server with our new variable. This is required because the \\nAnalyze application needs to know about our new variable as well as the Explore application, which will need to list our\\nnew variable and its description.\\n\\nThe second line is the call to <code>data.map()<\/code>. A map function applies an operation - here \\n<code>calcDichot()<\/code> to each row of our data table. In each row we <code>set()<\/code> the value\\nof our new variable <code>age_dichot<\/code> to the value returned by the <code>calcDichot()<\/code> \\nfunction. The one argument to <code>calcDichot()<\/code> is the value of column _age_ in the current row.\\n\\nWe can verify the success of the computation in the table and histogram displayed. Change the value of $120$ \\nand the page updates the table and the histogram after about 3 seconds. Any error messages are displayed \\nbelow the table.\"","source":"","permission":"public","name":"age_dichot","description":"Above 10 years of age at baseline"}